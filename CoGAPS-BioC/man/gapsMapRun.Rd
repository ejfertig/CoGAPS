% Generated by roxygen2 (4.0.1): do not edit by hand
\name{gapsMapRun}
\alias{gapsMapRun}
\title{\code{gapsMapRun} calls the C++ MCMC code and performs Bayesian
matrix factorization returning the two matrices that reconstruct
the data matrix; as opposed to gapsRun, this method takes an
additional input specifying set patterns in the P matrix}
\usage{
gapsMapRun(D, S, FP, nFactor = "7", simulation_id = "simulation",
  nEquil = "1000", nSample = "1000", nOutR = 1000,
  output_atomic = "FALSE", alphaA = "0.01", nMaxA = "100000",
  max_gibbmass_paraA = "100.0", lambdaA_scale_factor = "1.0",
  alphaP = "0.01", nMaxP = "100000", max_gibbmass_paraP = "100.0",
  lambdaP_scale_factor = "1.0")
}
\arguments{
\item{D}{data matrix}

\item{S}{uncertainty matrix (std devs for chi-squared of Log Likelihood)}

\item{FP}{data.frame with rows giving fixed patterns for P}

\item{nFactor}{number of patterns (basis vectors, metagenes), which must be
greater than or equal to the number of rows of FP}

\item{simulation_id}{name to attach to atoms files if created}

\item{nEquil}{number of iterations for burn-in}

\item{nSample}{number of iterations for sampling}

\item{nOutR}{how often to print status into R by iterations}

\item{output_atomic}{whether to write atom files (large)}

\item{alphaA,}{alphaP sparsity parameters for A and P domains}

\item{max_gibbmass_paraA(P)}{limit truncated normal to max size}

\item{nMaxA,}{nMaxP PRESENTLY UNUSED, future = limit number of atoms}

\item{lambdaA(P)_scale_factor}{lambda factor in penalized likelihood}
}
\description{
\code{gapsMapRun} calls the C++ MCMC code and performs Bayesian
matrix factorization returning the two matrices that reconstruct
the data matrix; as opposed to gapsRun, this method takes an
additional input specifying set patterns in the P matrix
}

